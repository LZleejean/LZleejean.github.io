[{"title":"A*算法游戏中需要考虑的几点","date":"2017-04-22T14:33:04.000Z","path":"2017/04/22/AStar算法游戏中需要考虑的几点/","text":"在实际游戏开发过程中采用A*算法，考虑清楚以下几点并采取适当的策略，那么必然可以得到一种高效美观合适的优化算法。 空间的划分：矩形栅格；四叉树；凸多边形；可见点；广义圆柱体 相邻状态：取决于地图表示和量化方式。比如在正方形栅格中，量化方式是只选择相邻位置-取周围8个还是4个，还有量化方式是取周围一定量的点（跟定义的规则有关），还要考虑地形（障碍物或者陆军不能过海） 代价：可以是距离，时间，花费点数等。这里还要考虑地形（穿越某种地形对应不同的代价）或者审美（看起来更直，更平滑。比如正方形栅格走对角比直线运动代价高）。甚至具有不对称性，从a-b代价比从b-a代价高（上坡等） 估价：到目标点的估价不要太高估（会导致找不到路径），但也不要太低（比如取两点间欧式距离，会导致效率降低，虽然一定可以找到最短路径）。所以估价函数的建立既要考虑最终结果不能太高估，又要考虑速度适当放大，甚至冒着取一条“次优路径”的风险进行高估。 目标：可能是多个目标点（比如一个角色在远处有多个攻击目标），所以需要首先获得这些目标，然后对一个新节点计算到每一个目标的cost，取最小的作为costToGoal。 另外，A算法一定不要用在判断两点是否有路径。因为假如无路径，会使一个大型地图几乎所有的点被搜索，效率最低。此时最好使用地图预分析，比如当两个点在两个隔离的岛上，则直接不调用A*。","tags":[{"name":"游戏编程","slug":"游戏编程","permalink":"http://lzzhenli.com/tags/游戏编程/"}]},{"title":"人民网解析池简单分析","date":"2017-04-17T15:00:42.000Z","path":"2017/04/17/人民网解析池分析/","text":"导语： 人民网是世界十大报纸之一《人民日报》建设的以新闻为主的大型网上信息交互平台，也是国际互联网上最大的综合性网络媒体之一。而作为一个著名的门户网站，信息量丰富，信息类别多样，网站结构复杂，反爬虫策略严密等特点使得结构化爬取该网站变得异常困难，本篇文章则重点讨论人民网网站结构以及给出一种较为有效的爬取策略。 一，网站整体结构人民网的网站结构如下所示，该网站内部链接比较清晰，首页与频道页，专题页以及内容页之间都是互相链接的，所以这势必会造成很多的重复url，不过庆幸地是我们的框架可以很轻松地完成上亿条数据的去重，所以这就大大减轻了解析模块的负担。 二，页面内部结构首页结构经分析人民网首页结构整体如下，s代表多个标签 body顶部有两个div标签广告以及一个section标签广告。之后则是十几个section，中间掺杂着若干个div标签的广告，底部则是分站与友情链接模块。很明显首页的所有新闻相关类链接全存在与section标签中（除去第一个），如此我们则可以通过这个特点来提取我们想要的url，比如通过xpath(“//section[position()&gt;1 and position()&lt;12]//a/@href”)。 获取url数据库展示： 频道页结构由于人民网频道种类的繁多，经验证发现频道间结构有较大差异，只有个别频道（如时政，财经等）结构大致相同，而大多频道差异性很大，这就造成了无法通过分析结构来写一个通用的频道页解析方法。还有一个较为尴尬的问题–有些新闻的url是相对路径。考虑到这些特殊性，所以最终决定通过暴力获取所有url，然后过滤掉不满足要求的url并为相对路径补充父亲节点。 我们需要的url具有如下特点： 字符串中包含n1–对应内容页 字符串中包含GB–对应内专题页 字符串中包含index–对应内频道页的翻页 字符串以.people.com.cn结尾 具体代码如下： self.links.append(selector.xpath( &apos;//a/@href&apos; )) parent = url.split(&apos;/&apos;)[0] self.links = filter(lambda x: &apos;/n1&apos; not in x and &apos;/GB&apos; not in x and &apos;index&apos; not in x, self.links) for i in range(0, len(self.links)): if self.links[i].startswith(&apos;/n1&apos;) or self.links[i].startswith(&apos;index&apos;): self.links[i] = parent + &apos;/&apos; + self.links[i] 专题页结构专题页面和频道页面差不多，甚至具有更大的差异性，所以我们采取和频道页面相同的处理方式。 内容页结构内容页结构如下所示，标题都在class= text_title的div标签的h1标签下，而新闻正文则是在id=rwb_zw的div标签的p标签下。所以我们可以分别通过这两个xpath来获取相应的新闻标题和正文。 即xpath(“//h1/text()”)–标题,xpath(“//*[@id=”rwb_zw”]/p/text()”)–正文 数据库结果展示： 程序源代码: https://github.com/LZleejean/PeopleSpider","tags":[{"name":"python 爬虫","slug":"python-爬虫","permalink":"http://lzzhenli.com/tags/python-爬虫/"}]},{"title":"A*算法入门浅谈","date":"2017-03-27T07:31:39.000Z","path":"2017/03/27/AStar算法入门浅谈/","text":"A*算法浅析 在玩游戏时，我们遇到过这样的场景：接到一个任务，需要前往某个坐标（例如npc，某个地区），此时我们点击任务列表中的坐标，我们的角色就会自动前往该目标，并且可以自动的规避一些障碍或者死胡同。那么这种AI路径规划技术就是A算法。本文将会简单介绍A算法的概念，并且给出一个最为简单的例子。 概述A*算法的原理呢，比较简单，这里我们就简单说明下。这个算法呢，是在状态空间上进行搜索的，通过检查某个状态的相邻状态来得到从起始状态到目标状态的最小代价路径。实质上就是反复检查它已经看到的但是还没有搜索到的最有希望的位置。而当目标位置被探索到时，算法终止。 原理通过维护两张表（OPEN，CLOSED）来标记地图上的未检查状态和已检查状态，对于某个结点，检查其相邻状态，然后选择最好的状态继续检查，直至检查到目标点。 从上面这段描述来看，有没有感觉有点熟悉？dijktra算法。确实，有点像，不过看完下面这张图，你就知道和dj算法哪里不同了。 A*算法维护着一个父状态以保证最终可以从终点通过父结点来回溯找到完整的路径；而dj算法只是求最短路径。 A*算法使用场景比较广泛，可以直接运用至游戏世界中；而dj算法是相对抽象的图场景。 还有一点这个图中体现的不明显。A*算法是启发式搜索，即尽可能朝着目标方向搜索；而dj算法在这种场景下则是一层层向外扩展。 从原理描述，我们可以提一个问题：怎么选择最好的状态？仅仅是离目标点最近吗？显然不行。对于最简单的无障碍物来说，影响不大。而对于有障碍物的情况，那么这种启发式会仅仅考虑到达目标的代价，而忽略了当前已花费的代价，于是尽管路径变得很长，它仍然继续走下去。 所以我们结合一下，共维护两种代价：一种是从开始状态到该状态的代价；另一种则是到达目标位置剩余距离的代价的一个启发式估价函数（例如离目标点最近）。而整个路径的估价值（前面两种代价相加）用以决定下一个要检查的状态即选择相邻状态中最好的那个。 实现目前A*的思路就很明显了。具体实现思路：closed表初始为空，open表只有初始状态。每次迭代，将open表中最好的状态（即Totalcost最小）取出检查。如不是目标状态，则检查它的相邻状态（如果是新状态，添加必要信息如父状态，CostFromStart，CostToGoal；如已经在open表中且代价更低，则更新该位置的信息如update新的父状态，代价等；如已经在closed表中，忽略）。 伪代码形式如下： AStarSearch(Location StartLoc, Location EndLoc) { //初始化起点 StartNode.Loc=StartLoc StartNode.CostFromStart=0 StartNode.CostToGoal=PathCost(StartLoc, EndLoc) StartNode.TotalCost=CostFromStart+CostToGoal StartNode.parent=NULL push StartNode on Open while Open is not empty { //按totalcost排序，将最小代价节点取出 pop Node from Open if (Node is Goal) { 构造路径 return success } else { for each NewNode of Node { NewCost = Node.GetCostFromStart() + GetCost(Node,NewNode) //已存在的就忽略 if (NewNode is in Closed or (NewNode is in Open and NewNode.CostFromStart 小于等于 NewCost)) { continue; } else { //在open表中则只更新数据 if (NewNode is in Open) { NewNode.Parent=Node NewNode.CostFromStart=NewCost NewNode.CostToGoal=PathCost(NewNode.Loc, EndLoc) NewNode.TotalCost=NewNode.CostFromStart+NewNode.CostToGoal } else { NewNode.Parent=Node NewNode.CostFromStart=NewCost NewNode.CostToGoal=PathCost(NewNode.Loc, EndLoc) NewNode.TotalCost=NewNode.CostFromStart+NewNode.CostToGoal push New Node to Open } } }//相邻状态遍历完毕 } push Node to Closed } return failure } 我用c++实现了一个最简单的形式，地图为方形栅格，无障碍物，取与目标点的欧几里得距离为启发式估价函数。设相邻状态对角的cost为14，直线的cost为10。 运行结果展示：我假设的起始点为(5,5).终点为(15,10) 这里的open表我采用的是list，其实有一种更好的方法就是采用优先级队列。这种方式实现起来会更简单，而且效率也会较高。 程序源代码: https://github.com/LZleejean/AStar 这里给大家推荐一个写的特别好的A*算法的文章。http://theory.stanford.edu/~amitp/GameProgramming/ 后续将会讨论一些A*算法优化问题。转载请注明出处","tags":[{"name":"游戏编程","slug":"游戏编程","permalink":"http://lzzhenli.com/tags/游戏编程/"}]},{"title":"Hello World","date":"2017-03-26T15:33:19.347Z","path":"2017/03/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]